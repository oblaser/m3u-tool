/*
author          Oliver Blaser
date            04.01.2024
copyright       GPL-3.0 - Copyright (c) 2024 Oliver Blaser
*/

#include <algorithm>
#include <array>
#include <cmath>
#include <filesystem>
#include <functional>
#include <iomanip>
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>

#include "application/common.h"
#include "middleware/encoding-helper.h"
#include "middleware/util.h"
#include "project.h"
#include "vstreamdl.h"

#include <omw/cli.h>
#include <omw/io/file.h>
#include <omw/string.h>
#include <omw/vector.h>


using std::cout;
using std::endl;

namespace fs = std::filesystem;

namespace
{
#ifdef PRJ_DEBUG
    const std::string magentaDebugStr = "\033[95mDEBUG\033[39m";
#endif
}



int app::vstreamdl(const app::Args& args, const app::Flags& flags)
{
    int r = EC_ERROR;

    IMPLEMENT_FLAGS();

    // TODO make nicer
    const std::string m3uFile = args.raw.at(1);
    const std::string outDir = args.raw.at(2);
    const std::string outName = args.raw.at(3);
    std::string maxResHStr = "1080";
    if (args.raw.size() > 4) maxResHStr = args.raw.at(4);

    util::ResultCounter rcnt = 0;

    const fs::path m3uFilePath = enc::path(m3uFile);
    const fs::path outDirPath = enc::path(outDir);

#if defined(PRJ_DEBUG) && 1
    app::dbg_rm_outDir(outDirPath);
#endif


    ///////////////////////////////////////////////////////////
    // check and read in file
    ///////////////////////////////////////////////////////////

    const m3u::HLS hls = getFromUri(flags, m3uFile);


    ///////////////////////////////////////////////////////////
    // check/create out dir
    ///////////////////////////////////////////////////////////

    app::checkCreateOutDir(flags, outDirPath, outDir);


    ///////////////////////////////////////////////////////////
    // process
    ///////////////////////////////////////////////////////////

    const std::string stemFileName = outName;

    if (!omw::isUInteger(maxResHStr)) ERROR_PRINT_EC_THROWLINE("invalid MAX-RES-HEIGHT", EC_ERROR);

    const int maxResHeight = std::stoi(maxResHStr);

    const bool noAudio = hls.audioStreams().empty();
    const bool noVideo = hls.streams().empty();
    const bool noSubtitles = hls.subtitles().empty();

    if (noAudio && noVideo && noSubtitles) ERROR_PRINT_EC_THROWLINE("empty stream", EC_STREAM_EMPTY);

    if (noAudio && !noVideo) WARNING_PRINT("no audio");
    if (!noAudio && noVideo) WARNING_PRINT("no video");
    if (!noAudio && !noVideo)
    {
        std::string txt = "";

        for (size_t i = 0; i < hls.otherEntries().size(); ++i)
        {
            txt += hls.otherEntries()[i].serialize();
            txt += m3u::serializeEndOfLine;
        }

        txt += m3u::serializeEndOfLine;

        for (size_t i = 0; i < hls.audioStreams().size(); ++i)
        {
            txt += hls.audioStreams()[i].serialize();
            txt += m3u::serializeEndOfLine;
        }

        txt += m3u::serializeEndOfLine;

        size_t streamIdx = 0;
        for (size_t i = 1; i < hls.streams().size(); ++i)
        {
            const int h = hls.streams()[i].resolutionHeight();

            if ((h > hls.streams()[streamIdx].resolutionHeight()) && (h <= maxResHeight)) streamIdx = i;
        }
        const auto& stream = hls.streams()[streamIdx];

        // no stream found with resolution <= maxResHeight
        if (stream.resolutionHeight() > maxResHeight)
        {
            // TODO improve with force and verbosity flags
            WARNING_PRINT("stream resolution: " + stream.resolutionExtParam().value().data());
        }

        txt += stream.serialize();
        txt += m3u::serializeEndOfLine;

        const auto outFile = outDirPath / enc::path(stemFileName + ".m3u");

        // TODO check if file exists
        util::writeFile(outFile, txt);

        INFO_PRINT("created file \"" + fs::weakly_canonical(outFile).u8string() + "\"");
    }
    else WARNING_PRINT("no audio and no video");

    if (!noSubtitles)
    {
        std::string srtScript = "# generated by " + std::string(prj::website) + "\n# " + util::getDateTimeStr() + "\n\nmkdir subs\n\n";

        for (const auto& st : hls.subtitles())
        {
            if (!st.uri().empty())
            {
                const std::string filename = "./subs/" + stemFileName + "-" + st.language() + (st.forced() ? "-forced" : "") + ".srt";

                srtScript += "ffmpeg -i \"" + st.uri() + "\" -scodec srt -loglevel warning \"" + filename + "\"\n";
                srtScript += "echo $?\n";
            }
        }

        const auto scriptFile = outDirPath / enc::path("dl-subs-" + stemFileName + ".sh");

        // TODO check if file exists
        util::writeFile(scriptFile, srtScript);
    }
    else if (verbose) INFO_PRINT("no subtitles");


    ///////////////////////////////////////////////////////////
    // end
    ///////////////////////////////////////////////////////////

    //if (verbose) cout << "\n" << omw::fgBrightGreen << "done" << omw::defaultForeColor << endl;
    r = EC_OK;

    return r;
}
